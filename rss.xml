<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>RSS 订阅酷酷时空</title>
        <link>cocosk.com</link>
        <description>RSS 酷酷时空</description>
        <lastBuildDate>Sat, 18 Jun 2016 23:35:05 CST</lastBuildDate>
        <language>zh-cn</language>
       
        <item>
            <title>使用go的ssh包快速打造一个本地命令行ssh客户端</title>
            <link>2016/6/18/go-ssh-client-1.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2016-06-18 11:52:00</pubDate>
            <description>&lt;p&gt;###🏂热身运动
&gt;在开始之前，先来个热身运动。虽然标题党写着快速打造一个ssh客户端，但是和跑步一样，在运动前还是需要先热身一下，不然到时候身体(大脑)会吃不消。所以，在开始前，我们先来科普一下ssh的一些东西。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;先来说说ssh，这里的ssh是指由IETF的网络小组（Network Working Group）所制定的为建立在应用层和传输层基础上的安全协议。（对于了解这个协议的请忽略本段文字😱）&lt;a href=&#34;http://baike.baidu.com/link?url=FaRrDm1hC0Xc-R-yqycKE83g2y7HziNpMuYehYI2E2HoYadXU4x_yD2jdMmTOafhhxhETKHNYthn2vKpAsGWFIqAURBvx2l2Zza_cV8FECW&#34;&gt;点这里了解更多ssh介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;写过java web应用的同学应该还知道另一个ssh(struts&#43;spring&#43;hibernate),当然今天的主角并不是它。😅&lt;/p&gt;

&lt;p&gt;其实接触过后端开发的同学对于ssh应该都不陌生，可能每天你都在使用它，没错，当你要远程登录服务器的时候，大多数情况下都离不开它，俨然已经成为Linux系统的标准配置。所以，如果你使用的是Linux操作系统，那么默认情况下就已经自带ssh的客户端了，于是乎你直接可以在Linux的shell中执行: &lt;code&gt;ssh user@host&lt;/code&gt; 就可以安全的登录到了远程主机host。对于ssh的更多命令或者玩法今天就不多介绍了，因为这不是今天的主要目标，今天的主要任务是实现一个和Linux操作系统中默认自带的ssh命令行客户端一样的使用go语言开发的ssh命令行客户端，当然由于时间篇幅有限，这次并不会实现原生ssh命令行客户端的全部功能，主要是能够实现远程登录到远程host，并能进行命令行操作。对于其他高级命令，如端口转发等将在后续完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;###🔪工欲善其事必先利其器&lt;/p&gt;

&lt;p&gt;既然说了要快速打造，那么必然需要借助一些现有的工具包了，这边为了完成这个客户端，笔者对原生的go语言的ssh包进行了一下封装做了一个小工具包gosshtool,可以从&lt;a href=&#34;http://git.oschina.net/scottkiss/gosshtool&#34;&gt;码云&lt;/a&gt;或者&lt;a href=&#34;https://github.com/scottkiss/gosshtool&#34;&gt;github&lt;/a&gt;找到。有了它，再来做ssh的客户端就轻松多了。&lt;/p&gt;

&lt;p&gt;###💻开始设计
首先，要完成一个命令行的ssh客户端，我们先来看下Linux下自带的ssh客户端是怎么工作的。这里所说的怎么工作，会站在比较高层的角度，因为ssh的整个通讯协议比较复杂，这里不过多介绍，原因是go提供的ssh包已经把底层的一些协议实现了，这里没必要自己再写一套实现出来，如果你确实对底层协议有兴趣，可以自己去网上查阅文档。那么站在比较高层角度来看，是如何的呢？
&gt;我们还原一个最常见的场景：某一天，你想登录远程主机，于是你打开了Linux的shell，
输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;ssh user@host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后输入密码后顺利的登录了host这个主机，接着你在shell输入一些命令，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看远程主机当前目录下所有文件。&lt;/p&gt;

&lt;p&gt;上述场景的过程，我们可以简单画一个图，来看看你这些操作是怎么与远程主机通讯的，如下图：
&lt;a href=&#34;/images/go-ssh-client/aaa.png&#34;&gt;&lt;img src=&#34;/images/go-ssh-client/aaa.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据上图，我们开始设计，首先要想办法读取用户的键盘输入，如：输入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;pwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在go语言中，我们可以使用os和bufio两个包，关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;inputReader := bufio.NewReader(os.Stdin)
input, err := inputReader.ReadString(&#39;\n&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码，我们就可以读取以换行结束的字符串。&lt;/p&gt;

&lt;p&gt;这样完成了图中的第一步，第二步，我们将要建立与远程主机的ssh连接，这时候可以用到前面介绍的工具gosshtool了，有了它完成这一步变得轻松许多。在介绍这一步之前，我们先来对这个将要实现的客户端再多啰嗦几句，为了使我们的客户端看起来更像Linux自带的ssh客户端，我们假设将要做的这个客户端名字叫sshcmd，我们将要完成的任务是到时候生成一个叫sshcmd的可执行文件，然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;./sshcmd user@host 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就建立了远程ssh连接，并返回远程主机登录信息，接着你可以继续在控制台输入后续命令，这些命令实际上是在远程主机执行的，就像Linux自带的ssh客户端一样。所以，我们还要用到go的一个叫做flag的包，这个包在写命令行程序的时候非常有用，它可以方便的对命令参数进行解析。所以我们会写到如下关键代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func main() {
  flag.StringVar(&amp;host, &#34;h&#34;, &#34;&#34;, &#34;host&#34;)
  flag.StringVar(&amp;passwd, &#34;p&#34;, &#34;&#34;, &#34;password&#34;)
  flag.Parse()
  hostsp := strings.Split(host, &#34;@&#34;)
  user = hostsp[0]
  host = hostsp[1]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们从命令行读取了user,host,password三个重要参数。有了它们，可以就可以建立ssh连接了关键代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt; config := &amp;gosshtool.SSHClientConfig{
    User:     user,
    Password: passwd,
    Host:     host,
  }
  sshclient := gosshtool.NewSSHClient(config)
  _, err := sshclient.Connect()
  if err == nil {
    fmt.Println(&#34;ssh connect success&#34;)
  } else {
    fmt.Println(&#34;ssh connect failed&#34;)
  }
  modes := ssh.TerminalModes{
    ssh.ECHO:          0,
    ssh.TTY_OP_ISPEED: 14400,
    ssh.TTY_OP_OSPEED: 14400,
  }
  pty := &amp;gosshtool.PtyInfo{
    Term:  &#34;xterm-256color&#34;,
    H:     80,
    W:     40,
    Modes: modes,
  }
  session, err := sshclient.Pipe(conn, pty, nil, 30)
  if err != nil {
    fmt.Println(err)
  }
  defer session.Close()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了gosshtool的NewSSHClient方法创建了一个客户端，并调用Connect()建立了连接，最后使用了Pipe(conn, pty, nil, 30)方法创建了一个保持会话，这样就号好了。这一切看起来如此简单，都要归功于Pipe这个方法，它的第一个参数是一个ReadWriteCloser接口类型，只要实现了该接口的结构都可以传入，这里我们会使用TCPConn这个结构，该结构实现了net.Conn接口，而net.Conn接口也是实现了ReadWriteCloser接口的。这个参数非常重要，我们建立了连接后，后续的通信全靠它了。你如果熟悉ReadWriteCloser接口，其实你就知道这个接口又组合了三个接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Reader interface {
    Read(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再看net.Conn接口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type Conn interface {
    // Read从连接中读取数据
    // Read方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    Read(b []byte) (n int, err error)
    // Write从连接中写入数据
    // Write方法可能会在超过某个固定时间限制后超时返回错误，该错误的Timeout()方法返回真
    Write(b []byte) (n int, err error)
    // Close方法关闭该连接
    // 并会导致任何阻塞中的Read或Write方法不再阻塞并返回错误
    Close() error
    // 返回本地网络地址
    LocalAddr() Addr
    // 返回远端网络地址
    RemoteAddr() Addr
    // 设定该连接的读写deadline，等价于同时调用SetReadDeadline和SetWriteDeadline
    // deadline是一个绝对时间，超过该时间后I/O操作就会直接因超时失败返回而不会阻塞
    // deadline对之后的所有I/O操作都起效，而不仅仅是下一次的读或写操作
    // 参数t为零值表示不设置期限
    SetDeadline(t time.Time) error
    // 设定该连接的读操作deadline，参数t为零值表示不设置期限
    SetReadDeadline(t time.Time) error
    // 设定该连接的写操作deadline，参数t为零值表示不设置期限
    // 即使写入超时，返回值n也可能&gt;0，说明成功写入了部分数据
    SetWriteDeadline(t time.Time) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比下会发现Conn接口也实现了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Read(b []byte) (n int, err error)&lt;/li&gt;
&lt;li&gt;Write(b []byte) (n int, err error)&lt;/li&gt;
&lt;li&gt;Close() error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这也说明了，确实我们可以将net.Conn的参数传入。通过接口方法，其实也可以看出这些接口都有一个共同作用，可以对字节进行读写操作。而我们要与远程主机网络通信，当然少不了这些。因此，所有实现以上三个方法的结构都是可以传入并于远程主机建立的ssh连接通信的。这里，我们的想法是：在本地起一个socket服务，并接受标准输入，最终将标准输入的数据通过Pipe转发给远程主机，实现本地终端输入命令通过ssh协议远程执行如下图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/images/go-ssh-client/bbb.png&#34;&gt;&lt;img src=&#34;/images/go-ssh-client/bbb.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;正如图中所示，实际上Pipe方法可以理解为将tcp连接转成了ssh连接并可以通过它传递数据。当然也可以将websocket的连接转成ssh连接，这样就可以实现基于web网页的ssh客户端了，也是非常简单的，这个后续介绍。介绍到这里，大部分关键的点都已经说完了，这里只是简单实现了一个最简单版本的ssh命令行客户端，当然通过gosshtool还可以做很多好玩的东西，比如部署工具，本地转发服务，命令行运维工具等。最后，最最关键的，放上本次实践的完整源码：
&lt;a href=&#34;https://github.com/scottkiss/sshcmd&#34;&gt;sshcmd源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;###总结
本文介绍了如何打造一个本地命令行ssh客户端，如果基于现成的工具包确实没多少工作量，而且大部分功能都实现比较粗糙，权当抛砖引玉。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2016/6/18/go-ssh-client-1.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2016&lt;/sup&gt;⁄&lt;sub&gt;6&lt;/sub&gt;/18/go-ssh-client-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>使用docker搭建nfs实现容器间共享文件</title>
            <link>2016/2/16/docker-nfs.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2016-02-16 11:52:00</pubDate>
            <description>&lt;p&gt;首先介绍下今天的两个主角:nfs和docker&lt;/p&gt;

&lt;h2&gt;nfs 是什么&lt;/h2&gt;

&lt;p&gt;NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。
摘自&lt;a href=&#34;http://baike.baidu.com/link?url=QduB9ZQNclk4p1b8t5_eLcjmSShlkGHKQhdI7vvmCpz7p-1U2ta_2HmukKzIr7laQj6-jujjkp6T4GK6hfhbbS4A1FL7UJE0iU8ctvhv_Oa&#34;&gt;百度百科&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;docker 是什么&lt;/h2&gt;

&lt;p&gt;这个就不多说了,近两年一个非常流行的东西哦。&lt;/p&gt;

&lt;p&gt;主角介绍完毕，那么要说说为什么要使用docker来搭建nfs，其实本文标题已经说明，主要目的还是为了实现容器间文件的共享。
用过docker的都应该知道docker可以支持容器目录挂载到宿主机。而通过nfs，则可以将容器之间的目录实现共享挂载。如果你有多个容器间需要共享文件的需求，这个将是一个可以尝试的方案，具体使用场景看大家发挥想象了，今天这里主要实践一下如何实现这个功能。&lt;/p&gt;

&lt;h2&gt;涉及到的知识&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;nfs安装&lt;/li&gt;
&lt;li&gt;docker容器间通信&lt;/li&gt;
&lt;li&gt;docker privileged&lt;/li&gt;
&lt;li&gt;dockerfile&lt;/li&gt;
&lt;li&gt;docker镜像&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;编写dockerfile&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;FROM ubuntu
ENV DEBIAN_FRONTEND noninteractive
RUN apt-get update -qq &amp;&amp; apt-get install -y nfs-kernel-server runit inotify-tools -qq
RUN mkdir -p /exports

VOLUME /exports

EXPOSE 111/udp 2049/tcp
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;制作docker镜像&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt; docker build -t=scottkiss/nfs .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行该命令需要一段时间，成功后执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将会看到本地刚刚创建nfs的docker镜像&lt;/p&gt;

&lt;h2&gt;配置并运行nfs服务器&lt;/h2&gt;

&lt;p&gt;执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -it --name nfs-server --privileged scottkiss/nfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行完毕后进入容器终端&lt;/p&gt;

&lt;p&gt;修改配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;vi /etc/exports
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在末尾加入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;/exports *(rw,sync,no_subtree_check,fsid=0,no_root_squash)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;exportfs -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着启动rpcbind服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;service rpcbind start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后启动nfs服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;service nfs-kernel-server start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，不出意外，已经成功的启动了nfs服务器，并且将/exports目录共享了出去。这里，笔者在开始的时候遇到一坑，
就是启动时候需要加上–privileged参数，否则启动nfs服务时候会提示权限不足报错。主要是这个过程中涉及到了mount操作，
使用该参数后使得container内的root拥有真正的root权限，这样就不会报错了。&lt;/p&gt;

&lt;h2&gt;配置并启动客户端&lt;/h2&gt;

&lt;p&gt;客户端就简单多了，不需要像服务器那样配置了。
执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;docker run -it --link nfs-server:nfs  --privileged scottkiss/nfs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入容器终端。然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;service rpcbind start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着执行远程挂载命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;mount -t nfs -o proto=tcp,port=2049 $NFS_PORT_2049_TCP_ADDR:/exports /home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，便将服务器的exports目录挂载到了客户端的home目录了。&lt;/p&gt;

&lt;p&gt;迫不及待的可以试试了，如在server终端的/exports目录下添加一个文件，在client的/home下也会同步添加。&lt;/p&gt;

&lt;p&gt;这里涉及的主要就是–link参数，这个参数就是告诉Docker容器需要使用nfs-server这个容器并将其别名命名为nfs。这样,就可以使用$NFS_PORT_2049_TCP_ADDR来获取服务器ip了。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;以上所有只是为了测试而做的一个粗糙的方案，还有很多改进之处，包括dockerfile，这里为了便于试验，尽量使用了简单粗暴的方式。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2015/2/16/docker-nfs.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2016&lt;/sup&gt;⁄&lt;sub&gt;2&lt;/sub&gt;/16/docker-nfs.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>docker pull 私有仓库镜像出错的问题</title>
            <link>2015/2/17/docker-pull-image-error.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2015-02-17 11:52:00</pubDate>
            <description>&lt;h2&gt;问题描述&lt;/h2&gt;

&lt;p&gt;通过docker pull命令来pull私有仓库image出现报错：&lt;/p&gt;

&lt;p&gt;FATA[0010] Error: v1 ping attempt failed with error: Get &lt;a href=&#34;https://111.xx.xx.xx/v1/_ping:&#34;&gt;https://111.xx.xx.xx/v1/_ping:&lt;/a&gt; dial tcp 111.xx.xx.xx:443: i/o timeout. If this private registry supports only HTTP or HTTPS with an unknown CA certificate, please add &lt;code&gt;--insecure-registry 111.xx.xx.xx&lt;/code&gt; to the daemon’s arguments. In the case of HTTPS, if you have access to the registry’s CA certificate, no need for the flag; simply place the CA certificate at /etc/docker/certs.d/111.xx.xx.xx/ca.crt&lt;/p&gt;

&lt;p&gt;根据错误提示，是CA的问题，我们需要在docker的启动参数加上-insecure-registry 111.xx.xx.xx，所以我们需要在vi /etc/default/docker,加上&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;DOCKER_OPTS=&#34;$DOCKER_OPTS --insecure-registry=111.xx.xx.xx&#34;
&lt;/pre&gt;

&lt;p&gt;然后重启Docker&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;sudo service docker restart
&lt;/pre&gt;

&lt;p&gt;但是，如果你是在OS X系统下使用boot2docker的，那么通过boot2docker ssh 进入到虚拟机，操作上述方法是不行的，当然有其他办法，那就是ssh到boot2docker虚拟机，然后修改vi /var/lib/boot2docker/profile 加入&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;EXTRA_ARGS=&#34;--insecure-registry=111.xx.xx.xx&#34;
&lt;/pre&gt;

&lt;p&gt;然后退出虚拟机,执行重启：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;boot2docker down&lt;/li&gt;
&lt;li&gt;boot2docker up&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后就可以从111.xx.xx.xx的私有仓库pull images了。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2015/2/17/docker-pull-image-error.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2015&lt;/sup&gt;⁄&lt;sub&gt;2&lt;/sub&gt;/17/docker-pull-image-error.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>快速学习ios开发：Objective-C基础(一)</title>
            <link>2015/2/7/learn-ios-dev-faster-oc-1.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2015-02-07 22:33:10</pubDate>
            <description>&lt;h2&gt;零、关于快速学习ios开发系列文章&lt;/h2&gt;

&lt;p&gt;为什么会要写这个系列？&lt;/p&gt;

&lt;p&gt;这是个好问题，其实我也不知道这个系列是否会和其他系列一样写着写着就搁置好多了，然后不知道什么时候才更新。但是无所谓，因为本来就是主要用来记录个人学习过程的，如果在这过程中能够帮助到别人也算是一件不错的事情。所以不要太期望文章一定会及时或者持续更新下去，就比如博客中其他文章一样，因为很多也只是记录个人学习历程，如果某个技术在实际工作或者学习中不需要继续深究下去了，可能就不会及时持续更新了，因为要忙的事情实在太多，当然，如果有时间的话，我还是非常希望能把未完结的所有系列文章都给来个大结局。这不，最近入手了Mac，当然得学习学习ios了。如果你也是新手，可以跟着一起玩玩。&lt;/p&gt;

&lt;h2&gt;一、需要准备的&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一台Mac&lt;/li&gt;
&lt;li&gt;Mac里装个Xcode，这里版本是6.1.1&lt;/li&gt;
&lt;li&gt;一只会编程的猴子&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述三个条件，前面两个应该都比较好搞定，第三个需要一个会编程的猴子，这个条件就比较特殊了，因为每只猴子的基础都不一样啊，什么？你不知道猴子是什么？那估计你不需要往下看了。当然猴子的基础越好，就越能掌握本系列的精髓－快速。所以，在学习过程中绝对不是那种《xxx入门》什么类型的，会花很多时间先来学学oc语言语法，然后一步一步截图展示如何创建一个hello world。所以做好准备，可能在学习过程中，你会需要另外去查阅资料。&lt;/p&gt;

&lt;h2&gt;二、从xxx语言到Objective-C&lt;/h2&gt;

&lt;p&gt;在ios开发中现在可以使用Objective-C或者是Swift开发语言。这里学习为什么不选Swift呢？虽然她比较新，而且相信未来发展也是非常不错的，但是目前第三方支持或者一些坑可能都没有前人踩过，所以还是选择稳定且但比较旧的Objective-C。当然，对于像笔者这样喜欢尝试各种语言的，到时候切换Swift也说不会有任何困难的。所以，这个标题也就变成了xxx语言到Objective-C了，因为笔者并不是从某一种语言转来的，而是一堆。所以我会在不同语言角度来看Objective-C的语法来对比，当然还是会选择一些比较常用的语言。
所以如果你还没有学过其他编程语言，可能就比较惨了，因为快速入门是建立在之前基础上的，建议还是乖乖的先学习一门语言并熟练运用再回来，不然看了也说浪费时间。&lt;/p&gt;

&lt;h2&gt;三、快速浏览Objective-C&lt;/h2&gt;

&lt;p&gt;既然要快速学，那我们肯定不是去拿本Objective-C的基本语法书从Hello World开始学起，于是我们就站在已经学会的角度去学，听起来有点怪怪的。首先我们来回答个问题，为什么学Objective-C？很明显，我们要拿它来写ios的应用或者游戏，于是，我们就清楚我们要做的了。当然说赶紧的打开Xcode，创建第一个项目。如下图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/assets/themes/sk/pic/ios1-1.png&#34;&gt;&lt;img src=&#34;/assets/themes/sk/pic/ios1-1.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/assets/themes/sk/pic/ios1-2.png&#34;&gt;&lt;img src=&#34;/assets/themes/sk/pic/ios1-2.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;按照上创建FirstApp，并设置项目名称等信息，然后可以就可以看下项目的结构了:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/assets/themes/sk/pic/ios1-3.png&#34;&gt;&lt;img src=&#34;/assets/themes/sk/pic/ios1-3.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;于是我们从目录结构来猜猜看，马上发现有个main.m的文件，学过C语言的应该有点印象，莫非它也是oc的入口函数，二话不说，打开之：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#import &lt;UIKit/UIKit.h&gt;
#import &#34;AppDelegate.h&#34;

int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
&lt;/pre&gt;

&lt;p&gt;好家伙，连main函数参数都和C语言的一样。那来找找不一样的呢，发现开头是#import而不是#include,他们具体异同点如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;#import是一个预处理指令，作用跟C语言的#include类似，包含某个文件的内容到预处理指令所在的位置。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在C\C&#43;&#43;中，我们用#include来包含头文件，但是同一个头文件可能被包含多次。为了解决这个问题，一般我们会这么写：&lt;/p&gt;

&lt;p&gt;#ifndef &lt;em&gt;APP_H&lt;/em&gt;
#define &lt;em&gt;APP_H&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;/&lt;em&gt;…..&lt;/em&gt;/&lt;/p&gt;

&lt;p&gt;#endif&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用#import来包含头文件，可以自动防止同一个头文件被包含多次。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;#import &lt;xxx&gt;表示包含系统自带的文件，#import “xxx”表示包含开发人员自己创建的文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们再来看main函数体的内容，发现有个@autoreleasepool，这个是什么东西？写过Java的都应该知道Java的垃圾回收机制，但是OC是不支持垃圾回收的，需要开发人员编写代码来释放对象所占用的内存。这个东西就是OC内存管理的一种东西－自动释放池，使用这个东西就可以方便开发人员不再需要每次手动的retain和release对象，这部分涉及到内存管理比较深入的东西了，暂且不深入了解，后续再说。&lt;/p&gt;

&lt;h2&gt;四、UIApplicationMain&lt;/h2&gt;

&lt;p&gt;我们打开UIApplicationMain的定义&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;UIKIT_EXTERN int UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName);
&lt;/pre&gt;

&lt;p&gt;嗯，看起来像是一个函数，但是前面有个UIKIT_EXTERN，继续查看源码：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#import &lt;Availability.h&gt;

#ifdef __cplusplus
#define UIKIT_EXTERN        extern &#34;C&#34; __attribute__((visibility (&#34;default&#34;)))
#else
#define UIKIT_EXTERN            extern __attribute__((visibility (&#34;default&#34;)))
#endif

#define UIKIT_STATIC_INLINE     static inline
&lt;/pre&gt;

&lt;p&gt;原来是一个宏定义，其中&lt;strong&gt;cplusplus是cpp中的自定义宏，如果这是一段cpp的代码，那么加入extern”C”和其中的代码。extern是C/C&#43;&#43;语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。C&#43;&#43;之父在设计C&#43;&#43;之时，考虑到当时已经存在了大量的C代码，为了支持原来的C代码和已经写好C库，需要在C&#43;&#43;中尽可能的支持C，而 extern “C”就是其中的一个策略。&lt;/strong&gt;attribute&lt;strong&gt;是GNU C的一种机制，用法为_attribute&lt;/strong&gt; ((attribute-list))。当项目需要作为一个库被外包引用的时候通常在编译时可以用参数-fvisibility指定所有符号的可见性。在编译命令中加入 -fvisibility=hidden参数，会将所有默认的public的属性变为hidden。此时，如果对函数设置&lt;strong&gt;attribute&lt;/strong&gt;((visibility (“default”)))参数，使特定的函数仍然按默认的public属性处理，则-fvisibility=hidden参数不会对该函数起作用。所以，设置了-fvisibility=hidden参数之后，只有设置了&lt;strong&gt;attribute&lt;/strong&gt;((visibility (“default”)))的函数才是对外可见的。&lt;/p&gt;

&lt;p&gt;上面讲了一大堆，总之呢，就是UIApplicationMain是界面相关的UIKit框架对外可见的一个函数。&lt;/p&gt;

&lt;p&gt;再来看看UIApplicationMain函数，它接收四个参数,其中argc和argv是main函数传过来的，该函数还需要两个字符串参数，用于标识应用程序的首要类（即应用程序对象所属的类）和应用程序委托类。果首要类字符串的值为nil, UIKit就缺省使用UIApplication类；如果应用程序委托类为nil，UIKit就会将应用程序主nib文件（针对通过Xcode模板创建的应用程序）中的某个对象假定为应用程序的委托对象。在这个例子中,应用程序委托类不是nil的，从之前的函数参数类型和参数名称来看，是自定义一个字符串类型的代理类名，但是是这样的：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;NSStringFromClass([AppDelegate class])
&lt;/pre&gt;

&lt;p&gt;打开NSStringFromClass定义看到：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass);
&lt;/pre&gt;

&lt;p&gt;这是FOUNDATION框架中提供的一个底层对外可见的函数，看意思应该是获取一个Class的名称。至于FOUNDATION和UIKIT框架，这里先不详细介绍了，后面准备讲整个ios开发框架架构时候再说。那么里面这个&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[AppDelegate class]
&lt;/pre&gt;

&lt;p&gt;是什么意思？这是OC中方法调用的一种语法，其实OC调用方法是使用“消息结构”（messaging structure）而非C&#43;&#43;等语言的“函数调用”（function calling)，关键区别在于：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。因此，OC是相当动态的，当调用一个实例的方法，在runtime时向该实例的指针发送消息，实例在收到消息后，从自身的实现中寻找响应这条消息的方法。基本语法如下：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[实例 方法]; 
&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[类名 方法名];
&lt;/pre&gt;

&lt;p&gt;前面讲过调用一个类或实例的方法，实际上是给这个类或实例发消息（message）。类或实例称为“接收方”。所以，调用方法的格式也可以理解为：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[接收方 消息];
&lt;/pre&gt;

&lt;p&gt;在术语上，整个表达式也叫消息表达式。如果有返回值，那么如下：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;变量＝[接收方 消息];
&lt;/pre&gt;

&lt;p&gt;如果要传递参数呢：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[Dog setName:“tom”];
&lt;/pre&gt;

&lt;p&gt;当然如果有多个参数：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[接收方 名字1:参数1 名字2:参数2, 名字3:参数3 .. ];
&lt;/pre&gt;

&lt;p&gt;为了避免声明过多的本地变量保存临时结果，Objective-C允许你使用嵌套消息。每个嵌套消息的返回值可以作为其他消息的参数或者目标。如下：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[NSString stringWithFormat:[dog getName]];
&lt;/pre&gt;

&lt;p&gt;虽然这样很方便，但是为了更好的代码可读性，建议避免在一行代码中嵌套调用超过两个方法。&lt;/p&gt;

&lt;p&gt;介绍了那么多关于关于消息传递的知识，现在终于可以理解&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;[AppDelegate class]
&lt;/pre&gt;

&lt;p&gt;其实意思就是向AppDelegate类发了class消息，那么这个消息（可以理解为一个方法调用）是什么呢？我们继续找到class的定义：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;&#43; (Class)class;
&lt;/pre&gt;

&lt;p&gt;在NSObject.h文件中找到了如上的声明，有点类似c&#43;&#43;中头文件中方法的声明。此处又出现奇怪的＋号，这个又是什么呢？请听下回分解。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2015/2/7/learn-ios-dev-faster-oc-1.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2015&lt;/sup&gt;⁄&lt;sub&gt;2&lt;/sub&gt;/7/learn-ios-dev-faster-oc-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>cocos2d-x 3.0学习-Android中集成Admob插页广告</title>
            <link>2014/8/17/cocos2d-x-3-android-Admob-InterstitialAd.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2014-08-17 19:00:00</pubDate>
            <description>&lt;h2&gt;一、主要步骤&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建一个免费的Admob账户: (&lt;a href=&#34;http://www.google.com/ads/admob/39)[http://www.google.com/ads/admob/39&#34;&gt;http://www.google.com/ads/admob/39)[http://www.google.com/ads/admob/39&lt;/a&gt;]&lt;/li&gt;
&lt;li&gt;创建一个新的app ID,并设置类型为插页广告的AdMob广告单元&lt;/li&gt;
&lt;li&gt;导入Google Play services，在eclipse中选择Windows -&gt; Android SDK Manager -&gt; Extras -&gt; “Google Play services” -&gt; Install packages&lt;/li&gt;
&lt;li&gt;修改AndroidManifest.xml文件新增如下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AndroidManifest.xml&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;meta-data android:name=&#34;com.google.android.gms.version&#34;
               android:value=&#34;@integer/google_play_services_version&#34;/&gt;
    &lt;activity android:name=&#34;com.google.android.gms.ads.AdActivity&#34;
              android:configChanges=&#34;keyboard|keyboardHidden|orientation|screenLayout|uiMode|screenSize|smallestScreenSize&#34;/&gt;
&lt;uses-permission android:name=&#34;android.permission.ACCESS_NETWORK_STATE&#34;/&gt;
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改AppActivity.java类如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AppActivity.java&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;public class AppActivity extends Cocos2dxActivity {

private static AppActivity _appActiviy;
private static final String AD_UNIT_ID = &#34;your-ad-unit-id&#34;; //你自己广告单元的ID
private static InterstitialAd interstitial;



@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

    interstitial = new InterstitialAd(this);
    interstitial.setAdUnitId(AD_UNIT_ID);
    _appActiviy = this;
    AdRequest adRequest = new AdRequest.Builder()
    .addTestDevice(AdRequest.DEVICE_ID_EMULATOR)
    .addTestDevice(&#34;HASH_DEVICE_ID&#34;)
    .build();

    interstitial.loadAd(adRequest);

}
public static void showInterstitial(){
    _appActiviy.runOnUiThread(new Runnable() {

        @Override
        public void run() {
             if (interstitial.isLoaded()) {
                  interstitial.show();
              }
        }
    });

    }

}
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;最后添加cpp代码，这与横幅广告一样：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AdmobHelper.h&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#ifndef  __ADMOB_HELPER_H_
#define  __ADMOB_HELPER_H_

class AdmobHelper
{
public:
    static void hideAd();
    static void showAd();
    static bool isAdShowing;

};
#endif // __ADMOB_HELPER_H_
&lt;/pre&gt;

&lt;p&gt;AdmobHelper.cpp&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#include &#34;AdmobHelper.h&#34;
#include &#34;cocos2d.h&#34;

bool AdmobHelper::isAdShowing = true;

#if (CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID)

#include &#34;platform/android/jni/JniHelper.h&#34;
#include &lt;jni.h&gt;
//#include &lt;android/log.h&gt;


const char* AppActivityClassName = &#34;org/cocos2dx/cpp/AppActivity&#34;;

void AdmobHelper::hideAd()
{
    cocos2d::JniMethodInfo t;
    if (cocos2d::JniHelper::getStaticMethodInfo(t, AppActivityClassName, &#34;hideAd&#34;, &#34;()V&#34;))
    {

        t.env-&gt;CallStaticVoidMethod(t.classID, t.methodID);
        t.env-&gt;DeleteLocalRef(t.classID);
        isAdShowing = false;
    }
}



void AdmobHelper::showAd()
{

    cocos2d::JniMethodInfo t;
    if (cocos2d::JniHelper::getStaticMethodInfo(t, AppActivityClassName, &#34;showAd&#34;, &#34;()V&#34;))
    {

        t.env-&gt;CallStaticVoidMethod(t.classID, t.methodID);
        t.env-&gt;DeleteLocalRef(t.classID);
        isAdShowing = true;
    }

}


#else


void AdmobHelper::hideAd()
{
    CCLOG(&#34;hideAd() called&#34;);
    isAdShowing = false;
    return; //nothing
}


void AdmobHelper::showAd()
{
    CCLOG(&#34;showAd() called&#34;);
    isAdShowing = true;
    return; //nothing;

}

#endif
&lt;/pre&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;简单讲述cocos2d-x-3在android中添加插页广告的步骤。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2014/8/17/cocos2d-x-3-android-Admob-InterstitialAd.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2014&lt;/sup&gt;⁄&lt;sub&gt;8&lt;/sub&gt;/17/cocos2d-x-3-android-Admob-InterstitialAd.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>cocos2d-x 3.0学习-响应android的back按键</title>
            <link>2014/7/21/cocos2d-x-3-android-backspace-key.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2014-07-21 22:50:00</pubDate>
            <description>&lt;h2&gt;一、响应android的back按键&lt;/h2&gt;

&lt;p&gt;我们都知道，cocos2d-x可以方便的构建不同平台的应用，当我们构建基于android的应用时，有时候我们可能需要用到android的返回按键。当然这个返回按键在iPhone手机上是找不到的（目前还是如此）。既然android有这个按键，cocos2d-x当然不会对它置之不理，在cocos2d-x可以方便的通过程序来响应返回按键动作。&lt;/p&gt;

&lt;h2&gt;二、简单的例子&lt;/h2&gt;

&lt;p&gt;这个例子是基于cocos2d-x 3.0的，以前的版本不一样哦，所以一定要看清楚你现在用的是什么版本。在cocos2d-x 3.0中，Layer类中有一个&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;virtual void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event);
&lt;/pre&gt;

&lt;p&gt;这样的虚方法，我们要想响应用户的按键动作，可以在相应的Layer中重写这个函数。为了方便在不同Layer中使用，我这里写了一个BaseLayer，这样如果想要在某个定义的Layer中响应onKeyReleased事件，只需要继承BaseLayer就可以了。&lt;/p&gt;

&lt;p&gt;BaseLayer.h&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#ifndef __BASE_LAYER_H__
#define __BASE_LAYER_H__

#include &#34;cocos2d.h&#34;

using namespace cocos2d;

class BaseLayer:public Layer{
public:
    virtual void onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event);
    bool virtual init();
};

#endif
&lt;/pre&gt;

&lt;p&gt;BaseLayer.cpp&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#include &#34;BaseLayer.h&#34;

void BaseLayer::onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event){
    if(keyCode == EventKeyboard::KeyCode::KEY_BACKSPACE){
         Director::getInstance()-&gt;popScene();
    }else if (keyCode == EventKeyboard::KeyCode::KEY_MENU){

    }
}

bool BaseLayer::init(){
    if(!Layer::init()){
        return false;
    }
    this-&gt;setKeyboardEnabled(true);

    return true;
}
&lt;/pre&gt;

&lt;p&gt;非常简单，但是还是简单解释下，注意在init函数中，我们调用了this-&gt;setKeyboardEnabled(true);这是非常重要的，否则按键将不会有响应效果。然后，我们看onKeyReleased函数中的参数，有一个是KeyCode，我们可以通过它来区分不同按键，KeyCode是一个enum&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt; enum class KeyCode
{
    KEY_NONE              = 0,
    KEY_PAUSE             = 0x0013,
    KEY_SCROLL_LOCK       = 0x1014,
    KEY_PRINT             = 0x1061,
    KEY_SYSREQ            = 0x106A,
    KEY_BREAK             = 0x106B,
    KEY_ESCAPE            = 0x001B,
    KEY_BACKSPACE         = 0x0008,
    KEY_TAB               = 0x000
    ...
 }
&lt;/pre&gt;

&lt;p&gt;这里我们需要处理KEY_BACKSPACE，所有正如上面代码所示，我们判断keyCode == EventKeyboard::KeyCode::KEY_BACKSPACE，如果是KEY_BACKSPACE，那么就处理这个按键的响应。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;简单讲述了如何在cocos2d-x中响应backspace按键。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2014/7/21/cocos2d-x-3-android-backspace-key.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2014&lt;/sup&gt;⁄&lt;sub&gt;7&lt;/sub&gt;/21/cocos2d-x-3-android-backspace-key.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>cocos2d-x 3.0学习-创建菜单场景</title>
            <link>2014/6/22/cocos2d-x-3-menu.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2014-06-22 10:50:00</pubDate>
            <description>&lt;h2&gt;一、创建菜单场景&lt;/h2&gt;

&lt;p&gt;我们在一个游戏中，通常打开游戏后都会有一个菜单场景，在菜单场景中你可以点击开始按钮，也可以点击其它例如设置等按钮。这是一个非常通用的场景，今天就来尝试创建一个menu的场景。&lt;/p&gt;

&lt;h2&gt;二、简单的例子 - hello Menu Scene&lt;/h2&gt;

&lt;p&gt;首先创建一个场景类:&lt;/p&gt;

&lt;p&gt;MenuScene.h&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#ifndef __MENU_SCENE_H__
#define __MENU_SCENE_H__


#include &#34;cocos2d.h&#34;

using namespace cocos2d;

class MenuScene:public Scene{
public:
    MenuScene();
    ~MenuScene();
    virtual bool init();
    CREATE_FUNC(MenuScene);

};
#endif
&lt;/pre&gt;

&lt;p&gt;MenuScene.cpp&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#include &#34;MenuScene.h&#34;
#include &#34;MenuLayer.h&#34;
#include &#34;BackgroundLayer.h&#34;

MenuScene::MenuScene(){};
MenuScene::~MenuScene(){};

bool MenuScene::init(){
    if(!Scene::init()){
        return false;
    }

    auto bgLayer = BackgroundLayer::create();
    if(bgLayer){
        this-&gt;addChild(bgLayer);
    }

    auto menuLayer = MenuLayer::create();
    if(menuLayer){
        this-&gt;addChild(menuLayer);
    }

    return true;
}
&lt;/pre&gt;

&lt;p&gt;可以看到在实现类中，我们在Scene中添加了两个层，一个是背景层，一个是菜单层。背景层就不说了，和创建普通层没什么区别，只是在层中添加一个背景图而已。下面看下菜单层：
MenuLayer.h&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#ifndef __MENU_LAYER_H__
#define __MENU_LAYER_H__

#include &#34;cocos2d.h&#34;

using namespace cocos2d;

class MenuLayer:public Layer{
public:
    virtual bool init();
    CREATE_FUNC(MenuLayer);
    void menuStartCallback(Object *sender);

};
#endif
&lt;/pre&gt;

&lt;p&gt;MenuLayer.cpp&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#include &#34;MenuLayer.h&#34;
#include &#34;GameScene.h&#34;

bool MenuLayer::init(){
if(!Layer::init()){
    return false;
}
Point origin = Director::getInstance()-&gt;getVisibleOrigin();
Size visiableSize = Director::getInstance()-&gt;getVisibleSize();
SpriteFrame *playBtnFrmae = SpriteFrameCache::getInstance()-&gt;getSpriteFrameByName(&#34;play_btn.png&#34;);
auto playBtn = Sprite::createWithSpriteFrame(playBtnFrmae);
auto activePlayBtn = Sprite::createWithSpriteFrame(playBtnFrmae);
activePlayBtn-&gt;setPositionY(7);
auto menuItem  = MenuItemSprite::create(playBtn,activePlayBtn,NULL,CC_CALLBACK_1(MenuLayer::menuStartCallback, this));
menuItem-&gt;setPosition(Point(origin.x &#43; visiableSize.width/2 ,origin.y &#43; visiableSize.height*2/5));

auto menu = Menu::create(menuItem,NULL);
menu-&gt;setPosition(Point(origin.x ,origin.y));
this-&gt;addChild(menu,1);
return true;
}

void MenuLayer::menuStartCallback(Object *sender){
    log(&#34;start game...&#34;);
    auto gameScene = GameScene::create();
    TransitionScene *transition = TransitionFade::create(1,gameScene);
    Director::getInstance()-&gt;replaceScene(transition);
}
&lt;/pre&gt;

&lt;p&gt;在菜单层中的init函数中，通过MenuItemSprite::create(playBtn,activePlayBtn,NULL,CC_CALLBACK_1(MenuLayer::menuStartCallback, this));创建了一个基于精灵的菜单项，其中第一个参数是一个精灵，第二个也是，只不过对第二个进行了Y方向的偏移。这样做的目的是第一个参数是正常情况菜单项显示的精灵（可以简单认为图片），第二个是当选中菜单项时候菜单项显示的精灵，这样就形成了动态效果。第三个参数是无效时候的菜单项显示，这里不需要所以是NULL，第四个参数是一个回调函数，就是当点击菜单项时候触发的函数。于是当点击的时候，就会调用：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;void MenuLayer::menuStartCallback(Object *sender){
    log(&#34;start game...&#34;);
    auto gameScene = GameScene::create();
    TransitionScene *transition = TransitionFade::create(1,gameScene);
    Director::getInstance()-&gt;replaceScene(transition);
}
&lt;/pre&gt;

&lt;p&gt;这里除了打印log外，创建了一个主游戏场景，并通过TransitionScene进行切换场景。还是回到上面，完成创建菜单项后，就可以创建菜单了，只要把菜单项放入菜单即可。当然这里只有一个菜单项，你可以可以尝试创建多个。最后将Menu对象放入层中，就好了。最后效果：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/assets/themes/bs/pic/menu.png&#34;&gt;&lt;img src=&#34;/assets/themes/bs/pic/menu.png&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;长得有点丑，哈哈，这里只是通过一个简单的例子来展示如何创建菜单场景的，你可以尝试加入更好看的元素，创建一个更漂亮的菜单场景。当然创建菜单的过程类似。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;一个小例子，展示如何在cocos2d-x中创建菜单场景。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2014/6/22/cocos2d-x-3-menu.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2014&lt;/sup&gt;⁄&lt;sub&gt;6&lt;/sub&gt;/22/cocos2d-x-3-menu.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>随便说说</title>
            <link>2014/6/15/talk-today.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2014-06-15 18:53:00</pubDate>
            <description>&lt;h2&gt;愉快的周末&lt;/h2&gt;

&lt;p&gt;这个应该是本博客的第一篇非技术类文章。之前一直不想发非技术类的文章，觉得要发点有用的东西给读者看才好，不过，今天就破例一次了。因为今天是一个愉快的周末。原因是今天一口气修复了基于Go语言的静态博客引擎(&lt;a href=&#34;https://github.com/scottkiss/gosk&#34;&gt;gosk&lt;/a&gt;)的好几个bug，真是大快人心。其实这些bug遗留很久了，一直没这个动力去修复，其中一个就是如果编辑的文章里面有代码，对于代码高亮处理有些bug，对于类xml的代码（包含小尖括号的code）需要真实以代码显示的，到前台却一起和其它文章内容一样被转码了，之前方法是放在前台脚本中js来处理，虽然勉强实现了，但是有各种bug，而且速度超慢。之前一直拖着，觉得这个东西可能要花些时间才能搞定，就不想浪费时间，今天实在是忍不下去了，结果没想象中的那么花费时间。看来有时候只要下决心，一些你想像很麻烦的事情其实也没那么麻烦，一个拖了将近半年的问题，一会会解决。另外还更新了cocos2d-x的一篇小文章，顺带完成了最近在做的一个游戏的一个场景。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2014/6/15/talk-today.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2014&lt;/sup&gt;⁄&lt;sub&gt;6&lt;/sub&gt;/15/talk-today.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>cocos2d-x 3.0学习-使用Physicals创建物理世界</title>
            <link>2014/6/15/cocos2d-x-3-physicals.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2014-06-15 11:50:00</pubDate>
            <description>&lt;h2&gt;一、创建物理世界&lt;/h2&gt;

&lt;p&gt;在cocos2d-x 3.0版本中，封装了方便模拟物理世界操作的一系列physicals类，在这之前一般是将box2d或者chipmunk集成到cocos2d-x中来。而现在，就方便多了，到底多简单？看看就知道。接下来就来实现一个简单的物理世界吧。&lt;/p&gt;

&lt;h2&gt;二、简单的例子 - hello Physicals world&lt;/h2&gt;

&lt;p&gt;首先创建一个场景:&lt;/p&gt;

&lt;p&gt;PhyScene.h&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#ifndef __PHY_SCENE_H__
#define __PHY_SCENE_H__


#include &#34;cocos2d.h&#34;

using namespace cocos2d;

class PhySceneDemo:public Layer{
public:
    virtual bool init();
    static Scene* scene();
    CREATE_FUNC(PhySceneDemo);
    void setPhyWorld(PhysicsWorld *phyworld){this-&gt;m_world=phyworld;}
    void PhySceneDemo::onTouchesEnded(const std::vector&lt;Touch*&gt;&amp; touches, Event *event);

private:
    PhysicsWorld *m_world;

};

#endif
&lt;/pre&gt;

&lt;p&gt;PhyScene.cpp&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;#include &#34;PhyScene.h&#34;

Scene* PhySceneDemo::scene(){
    auto scene = Scene::createWithPhysics();
    auto layer = PhySceneDemo::create();
    layer-&gt;setPhyWorld(scene-&gt;getPhysicsWorld());
    scene-&gt;addChild(layer);
    return scene;
}

bool PhySceneDemo::init(){

    if(!Layer::init()){
        return false;
    }

    Size visiableSize = Director::getInstance()-&gt;getVisibleSize();
    Point point = Director::getInstance()-&gt;getVisibleOrigin();
    edge = Sprite::create();

    auto body = PhysicsBody::createEdgeBox(visiableSize,PHYSICSBODY_MATERIAL_DEFAULT,3);
    edge-&gt;setPosition(Point(visiableSize.width/2,visiableSize.height/2));
    edge-&gt;setPhysicsBody(body);
    this-&gt;addChild(edge);
    edge-&gt;setTag(0);
    this-&gt;setTouchEnabled(true);

    return true;
}

void PhySceneDemo::onTouchesEnded(const std::vector&lt;Touch*&gt;&amp; touches, Event *event){
    for(Touch *touch:touches){
        auto location = touch-&gt;getLocation();
        Sprite *sprite = Sprite::create(&#34;hero_00.png&#34;);
        sprite-&gt;setPosition(location);
        sprite-&gt;setTag(1);
        auto sbody = PhysicsBody::createBox(Size(31,32));
        sprite-&gt;setPhysicsBody(sbody);

        this-&gt;addChild(sprite);
    }

}
&lt;/pre&gt;

&lt;p&gt;最后修改AppDelegate.cpp文件，将启动Scene设置成PhySceneDemo：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;auto scene = PhySceneDemo::scene();
// run
director-&gt;runWithScene(scene);
&lt;/pre&gt;

&lt;p&gt;通过以上代码便完成了具有物理效果的一个物理场景，是不是非常简单，最后看下运行效果，然后我们再解释关键代码的意思。
&lt;a href=&#34;/assets/themes/bs/pic/cocos_phy.gif&#34;&gt;&lt;img src=&#34;/assets/themes/bs/pic/cocos_phy.gif&#34; alt=&#34;&#34; /&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;三、关键代码讲解&lt;/h2&gt;

&lt;p&gt;相信大家都看到上图的效果了，那么现在来具体讲解下前面程序中，是如何创建一个物理世界的。
首先还是创建了一个场景叫做PhyScene.h的头文件，其中大部分与普通场景的创建类似，比如自带的HelloWorld场景。只不过新增了一个PhysicsWorld *m_world 的私有成员变量和一个void setPhyWorld(PhysicsWorld *phyworld){this-&gt;m_world=phyworld;}成员函数。由于PhySceneDemo类其实是一个继承Layer的类，本身是没有PhysicsWorld的，PhysicsWorld是在Scene类中的，上面新增的这两个就是将Scene的PhysicsWorld传递到Layer中，是得Layer具有物理世界的性质。具体传递可以看PhyScene.cpp的scene成员函数的实现，里面有&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;layer-&gt;setPhyWorld(scene-&gt;getPhysicsWorld());
&lt;/pre&gt;

&lt;p&gt;这样，Layer中就有了PhysicsWorld，然后可以让添加到Layer中的Sprite等节点具有物理特效。具体来看init实现中的：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;edge = Sprite::create();
auto body = PhysicsBody::createEdgeBox(visiableSize,PHYSICSBODY_MATERIAL_DEFAULT,3);
edge-&gt;setPosition(Point(visiableSize.width/2,visiableSize.height/2));
edge-&gt;setPhysicsBody(body);
this-&gt;addChild(edge);
&lt;/pre&gt;

&lt;p&gt;关键创建一个PhysicsBody对象，但是我们看到这里是用createEdgeBox创建的。而后面的onTouchesEnded函数中的又是使用createBox函数创建的，其实还有更多的创建方式。虽然都是返回PhysicsBody对象，但是效果不一样。举例说明前者，我们进入createEdgeBox函数实现可以看到：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt; PhysicsBody* body = new PhysicsBody();
 if (body &amp;&amp; body-&gt;init())
 {
    body-&gt;addShape(PhysicsShapeEdgeBox::create(size, material, border, offset));
    body-&gt;_dynamic = false;
    body-&gt;autorelease();
    return body;
 }
&lt;/pre&gt;

&lt;p&gt;其实在创建PhysicsBody对象的同时，会给他赋予Shape属性和其它一些属性，这里是一个PhysicsShapeEdgeBox，从名称可以看到是一个边缘盒子模型(物理世界的边缘)。最后设置精灵对象的PhysicsBody属性为之前的body对象，这样这个精灵就成为了一个物理世界的精灵。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;简单介绍了如何使用texturepacker并在cocos2d-x中创建精灵动画。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2014/6/15/cocos2d-x-3-physicals.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2014&lt;/sup&gt;⁄&lt;sub&gt;6&lt;/sub&gt;/15/cocos2d-x-3-physicals.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
        <item>
            <title>java servlet简单实现http服务器推</title>
            <link>2014/5/29/http-server-push.html</link>
            <author>卧雪Sirk</author>
            <pubDate>2014-05-29 15:52:00</pubDate>
            <description>&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;这几天有个小伙伴要实现http协议的服务器推的业务,于是就简单实现了下，且利用客户端模拟持续发送请求，模拟双向通信，当然只是一种简单的模型，如要应用于实际请慎重！&lt;/p&gt;

&lt;p&gt;客户端代码:&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;package com.test.client;

import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpLongConnectionClient {
public static void main(String[] args) {
    try {

         URL url = new URL(&#34;http://localhost:8080/TestWeb/test.do&#34;);  
          ReqRunnable rr = new ReqRunnable(url);
            Thread reqThread = new Thread(rr);
            reqThread.start();

            InputStream in=url.openStream();  
            int n = -1;  
            byte[] b = new byte[1024];

            while((n=in.read(b))!=-1)  
            {  
                String s=new String(b,0,n);  
                System.out.println(s);      
            }  

    } catch (Exception e) {
        e.printStackTrace();
    }
}

static class ReqRunnable implements Runnable{
    URL url;
    ReqRunnable(URL url){
        this.url = url;
    }
    @Override
    public void run() {
        try {
            int count=0;
            while(true){
                //模拟新事件产生
                HttpURLConnection conn = (HttpURLConnection) this.url.openConnection();
                conn.setDoOutput(true);
                conn.setRequestMethod(&#34;POST&#34;);
                conn.setRequestProperty(&#34;content-type&#34;, &#34;application/x-www-form-urlencoded&#34;);
                conn.setUseCaches(false);
                OutputStreamWriter out = new  OutputStreamWriter (conn.getOutputStream());
                String test = &#34;data=yes&#34;&#43;count&#43;&#43;;
                out.write(test);
                System.out.println(&#34;===&gt;&#34;&#43;test);
                out.flush();                                         
                out.close();
                InputStream inputStream = conn.getInputStream();  
                Thread.sleep(3000);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
}    
&lt;/pre&gt;

&lt;p&gt;服务器端代码:&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;public class TestServlet extends HttpServlet {
private static final long serialVersionUID = 1L;


    public TestServlet() {
        super();
    }


protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

    try{
        PrintWriter out = response.getWriter();
        int count = 0;
        while(true){
            System.out.println(&#34;read from client&#34;&#43;request.getParameter(&#34;data&#34;));
            out.println(&#34;hello&#34;&#43;count);
            out.flush();
            Thread.sleep(1000);
            count&#43;&#43;;
        }
    }catch(Exception e){
        e.printStackTrace();
    }

}

}
&lt;/pre&gt;

&lt;h2&gt;小结&lt;/h2&gt;

&lt;p&gt;简单实现http协议服务器推，感觉写得好恶心，纯属娱乐~ 后续研究更好的方案。&lt;/p&gt;

&lt;p&gt;##文档信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;版权声明：自由转载-非商用-非衍生-保持署名 | &lt;a href=&#34;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#34;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;原文网址：&lt;a href=&#34;http://www.cocosk.com/articles/2014/5/29/http-server-push.html&#34;&gt;http://www.cocosk.com/articles/&lt;sup&gt;2014&lt;/sup&gt;⁄&lt;sub&gt;5&lt;/sub&gt;/29/http-server-push.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：卧雪Sirk&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
       
    </channel>
</rss>